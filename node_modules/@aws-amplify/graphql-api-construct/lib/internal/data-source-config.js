"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateDataSourceStrategy = exports.schemaByMergingDefinitions = exports.getDataSourceStrategiesProvider = exports.constructCustomSqlDataSourceStrategies = void 0;
const graphql_1 = require("graphql");
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
/**
 * Creates an interface flavor of customSqlDataSourceStrategies from a factory method's schema and data source. Internally, this function
 * scans the fields of `Query` and `Mutation` looking for fields annotated with the `@sql` directive and designates the specified
 * dataSourceStrategy to fulfill those custom queries.
 *
 * Note that we do not scan for `Subscription` fields: `@sql` directives are not allowed on those, and it wouldn't make sense to do so
 * anyway, since subscriptions are processed from an incoming Mutation, not as the result of a direct datasource access.
 */
const constructCustomSqlDataSourceStrategies = (schema, dataSourceStrategy) => {
    if (!(0, graphql_transformer_core_1.isSqlStrategy)(dataSourceStrategy)) {
        return [];
    }
    const parsedSchema = (0, graphql_1.parse)(schema);
    const queryNode = parsedSchema.definitions.find(graphql_transformer_core_1.isQueryNode);
    const mutationNode = parsedSchema.definitions.find(graphql_transformer_core_1.isMutationNode);
    if (!queryNode && !mutationNode) {
        return [];
    }
    const customSqlDataSourceStrategies = [];
    if (queryNode) {
        const fields = (0, graphql_transformer_core_1.fieldsWithSqlDirective)(queryNode);
        for (const field of fields) {
            customSqlDataSourceStrategies.push({
                typeName: 'Query',
                fieldName: field.name.value,
                strategy: dataSourceStrategy,
            });
        }
    }
    if (mutationNode) {
        const fields = (0, graphql_transformer_core_1.fieldsWithSqlDirective)(mutationNode);
        for (const field of fields) {
            customSqlDataSourceStrategies.push({
                typeName: 'Mutation',
                fieldName: field.name.value,
                strategy: dataSourceStrategy,
            });
        }
    }
    return customSqlDataSourceStrategies;
};
exports.constructCustomSqlDataSourceStrategies = constructCustomSqlDataSourceStrategies;
/**
 * Extracts the data source provider from the definition. This jumps through some hoops to avoid changing the public interface. If we decide
 * to change the public interface to simplify the structure, then this process gets a lot simpler.
 */
const getDataSourceStrategiesProvider = (definition) => {
    const provider = {
        // We can directly use the interface strategies, even though the SQL strategies have the customSqlStatements field that is unused by the
        // transformer flavor of this type
        dataSourceStrategies: definition.dataSourceStrategies,
        sqlDirectiveDataSourceStrategies: [],
    };
    // We'll collect all the custom SQL statements from the definition into a single map, and use that to make our
    // SqlDirectiveDataSourceStrategies
    const customSqlStatements = {};
    const constructSqlStrategies = definition.customSqlDataSourceStrategies ?? [];
    // Note that we're relying on the `customSqlStatements` object reference to stay the same throughout this loop. Don't reassign it, or the
    // collected sqlDirectiveStrategies will break
    constructSqlStrategies.forEach((sqlStrategy) => {
        if (sqlStrategy.strategy.customSqlStatements) {
            Object.assign(customSqlStatements, sqlStrategy.strategy.customSqlStatements);
        }
        provider.sqlDirectiveDataSourceStrategies.push({
            typeName: sqlStrategy.typeName,
            fieldName: sqlStrategy.fieldName,
            strategy: sqlStrategy.strategy,
            customSqlStatements,
        });
    });
    return provider;
};
exports.getDataSourceStrategiesProvider = getDataSourceStrategiesProvider;
/**
 * Creates a new schema by merging the individual schemas contained in the definitions, combining fields of the Query and Mutation types in
 * individual definitions into a single combined definition. Adding directives to `Query` and `Mutation` types participating in a
 * combination is not supported (the behavior is undefined whether those directives are migrated).
 */
const schemaByMergingDefinitions = (definitions) => {
    const schema = definitions.map((def) => def.schema).join('\n');
    const parsedSchema = (0, graphql_1.parse)(schema);
    // We store the Query & Mutation definitions separately. Since the interfaces are readonly, we'll have to re-compose the types after we've
    // collected all the fields
    const queryAndMutationDefinitions = {};
    // Throws if the field has already been encountered
    const validateField = (typeName, fieldName) => {
        const fields = queryAndMutationDefinitions[typeName]?.fields;
        if (!fields) {
            return;
        }
        if (fields.find((field) => field.name.value === fieldName)) {
            throw new Error(`The custom ${typeName} field '${fieldName}' was found in multiple definitions, but a field name cannot be shared between definitions.`);
        }
    };
    // Transform the schema by reducing Mutation & Query types:
    // - Collect Mutation and Query definitions
    // - Alter the parsed schema by filtering out Mutation & Query types
    // - Add the combined Mutation & Query definitions to the filtered schema
    parsedSchema.definitions.filter(graphql_transformer_core_1.isBuiltInGraphqlNode).forEach((def) => {
        const typeName = def.name.value;
        if (!queryAndMutationDefinitions[typeName]) {
            queryAndMutationDefinitions[typeName] = {
                node: def,
                // `ObjectTypeDefinitionNode.fields` is a ReadonlyArray; so we have to create a new mutable array to collect all the fields
                fields: [...(def.fields ?? [])],
            };
            return;
        }
        (def.fields ?? []).forEach((field) => {
            validateField(typeName, field.name.value);
        });
        queryAndMutationDefinitions[typeName].fields = [...queryAndMutationDefinitions[typeName].fields, ...(def.fields ?? [])];
    });
    // Gather the collected Query & Mutation fields into <=2 new definitions
    const combinedDefinitions = Object.values(queryAndMutationDefinitions)
        .sort((a, b) => a.node.name.value.localeCompare(b.node.name.value))
        .reduce((acc, cur) => {
        const definitionNode = {
            ...cur.node,
            fields: cur.fields,
        };
        return [...acc, definitionNode];
    }, []);
    // Filter out the old Query & Mutation definitions
    const filteredDefinitions = parsedSchema.definitions.filter((def) => !(0, graphql_transformer_core_1.isBuiltInGraphqlNode)(def));
    // Compose the new schema by appending the collected definitions to the filtered definitions. This means that every query will be
    // rewritten such that the Mutation and Query types appear at the end of the schema.
    const newSchema = {
        ...parsedSchema,
        definitions: [...filteredDefinitions, ...combinedDefinitions],
    };
    const combinedSchemaString = (0, graphql_1.print)(newSchema);
    return combinedSchemaString;
};
exports.schemaByMergingDefinitions = schemaByMergingDefinitions;
/*
 * Validates the user input for the dataSourceStrategy. This is a no-op for DynamoDB strategies for now.
 * @param strategy user provided model data source strategy
 * @returns validates and throws an error if the strategy is invalid
 */
const validateDataSourceStrategy = (strategy) => {
    if (!(0, graphql_transformer_core_1.isSqlStrategy)(strategy)) {
        return;
    }
    const dbConnectionConfig = strategy.dbConnectionConfig;
    const invalidSSMPaths = Object.values(dbConnectionConfig).filter((value) => typeof value === 'string' && !isValidSSMPath(value));
    if (invalidSSMPaths.length > 0) {
        throw new Error(`Invalid data source strategy "${strategy.name}". Following SSM paths must start with '/' in dbConnectionConfig: ${invalidSSMPaths.join(', ')}.`);
    }
};
exports.validateDataSourceStrategy = validateDataSourceStrategy;
const isValidSSMPath = (path) => {
    return path.startsWith('/');
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1zb3VyY2UtY29uZmlnLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ludGVybmFsL2RhdGEtc291cmNlLWNvbmZpZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxxQ0FBbUk7QUFDbkksb0ZBTStDO0FBUS9DOzs7Ozs7O0dBT0c7QUFDSSxNQUFNLHNDQUFzQyxHQUFHLENBQ3BELE1BQWMsRUFDZCxrQkFBb0QsRUFDWixFQUFFO0lBQzFDLElBQUksQ0FBQyxJQUFBLHdDQUFhLEVBQUMsa0JBQWtCLENBQUMsRUFBRTtRQUN0QyxPQUFPLEVBQUUsQ0FBQztLQUNYO0lBRUQsTUFBTSxZQUFZLEdBQUcsSUFBQSxlQUFLLEVBQUMsTUFBTSxDQUFDLENBQUM7SUFFbkMsTUFBTSxTQUFTLEdBQUcsWUFBWSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsc0NBQVcsQ0FBQyxDQUFDO0lBQzdELE1BQU0sWUFBWSxHQUFHLFlBQVksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLHlDQUFjLENBQUMsQ0FBQztJQUNuRSxJQUFJLENBQUMsU0FBUyxJQUFJLENBQUMsWUFBWSxFQUFFO1FBQy9CLE9BQU8sRUFBRSxDQUFDO0tBQ1g7SUFFRCxNQUFNLDZCQUE2QixHQUEyQyxFQUFFLENBQUM7SUFFakYsSUFBSSxTQUFTLEVBQUU7UUFDYixNQUFNLE1BQU0sR0FBRyxJQUFBLGlEQUFzQixFQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2pELEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxFQUFFO1lBQzFCLDZCQUE2QixDQUFDLElBQUksQ0FBQztnQkFDakMsUUFBUSxFQUFFLE9BQU87Z0JBQ2pCLFNBQVMsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUs7Z0JBQzNCLFFBQVEsRUFBRSxrQkFBa0I7YUFDN0IsQ0FBQyxDQUFDO1NBQ0o7S0FDRjtJQUVELElBQUksWUFBWSxFQUFFO1FBQ2hCLE1BQU0sTUFBTSxHQUFHLElBQUEsaURBQXNC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Q0FBQztBQWRXLFFBQUEsMEJBQTBCLDhCQWNyQztBQUVGLE1BQU0sY0FBYyxHQUFHLENBQUMsSUFBWSxFQUFXLEVBQUU7SUFDL0MsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzlCLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERlZmluaXRpb25Ob2RlLCBGaWVsZERlZmluaXRpb25Ob2RlLCBJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbk5vZGUsIE9iamVjdFR5cGVEZWZpbml0aW9uTm9kZSwgcGFyc2UsIHByaW50IH0gZnJvbSAnZ3JhcGhxbCc7XG5pbXBvcnQge1xuICBpc0J1aWx0SW5HcmFwaHFsTm9kZSxcbiAgaXNTcWxTdHJhdGVneSxcbiAgaXNRdWVyeU5vZGUsXG4gIGlzTXV0YXRpb25Ob2RlLFxuICBmaWVsZHNXaXRoU3FsRGlyZWN0aXZlLFxufSBmcm9tICdAYXdzLWFtcGxpZnkvZ3JhcGhxbC10cmFuc2Zvcm1lci1jb3JlJztcbmltcG9ydCB7IERhdGFTb3VyY2VTdHJhdGVnaWVzUHJvdmlkZXIgfSBmcm9tICdAYXdzLWFtcGxpZnkvZ3JhcGhxbC10cmFuc2Zvcm1lci1pbnRlcmZhY2VzJztcbmltcG9ydCB7XG4gIEN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVneSBhcyBDb25zdHJ1Y3RDdXN0b21TcWxEYXRhU291cmNlU3RyYXRlZ3ksXG4gIE1vZGVsRGF0YVNvdXJjZVN0cmF0ZWd5IGFzIENvbnN0cnVjdE1vZGVsRGF0YVNvdXJjZVN0cmF0ZWd5LFxufSBmcm9tICcuLi9tb2RlbC1kYXRhc291cmNlLXN0cmF0ZWd5LXR5cGVzJztcbmltcG9ydCB7IElBbXBsaWZ5R3JhcGhxbERlZmluaXRpb24gfSBmcm9tICcuLi90eXBlcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnRlcmZhY2UgZmxhdm9yIG9mIGN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVnaWVzIGZyb20gYSBmYWN0b3J5IG1ldGhvZCdzIHNjaGVtYSBhbmQgZGF0YSBzb3VyY2UuIEludGVybmFsbHksIHRoaXMgZnVuY3Rpb25cbiAqIHNjYW5zIHRoZSBmaWVsZHMgb2YgYFF1ZXJ5YCBhbmQgYE11dGF0aW9uYCBsb29raW5nIGZvciBmaWVsZHMgYW5ub3RhdGVkIHdpdGggdGhlIGBAc3FsYCBkaXJlY3RpdmUgYW5kIGRlc2lnbmF0ZXMgdGhlIHNwZWNpZmllZFxuICogZGF0YVNvdXJjZVN0cmF0ZWd5IHRvIGZ1bGZpbGwgdGhvc2UgY3VzdG9tIHF1ZXJpZXMuXG4gKlxuICogTm90ZSB0aGF0IHdlIGRvIG5vdCBzY2FuIGZvciBgU3Vic2NyaXB0aW9uYCBmaWVsZHM6IGBAc3FsYCBkaXJlY3RpdmVzIGFyZSBub3QgYWxsb3dlZCBvbiB0aG9zZSwgYW5kIGl0IHdvdWxkbid0IG1ha2Ugc2Vuc2UgdG8gZG8gc29cbiAqIGFueXdheSwgc2luY2Ugc3Vic2NyaXB0aW9ucyBhcmUgcHJvY2Vzc2VkIGZyb20gYW4gaW5jb21pbmcgTXV0YXRpb24sIG5vdCBhcyB0aGUgcmVzdWx0IG9mIGEgZGlyZWN0IGRhdGFzb3VyY2UgYWNjZXNzLlxuICovXG5leHBvcnQgY29uc3QgY29uc3RydWN0Q3VzdG9tU3FsRGF0YVNvdXJjZVN0cmF0ZWdpZXMgPSAoXG4gIHNjaGVtYTogc3RyaW5nLFxuICBkYXRhU291cmNlU3RyYXRlZ3k6IENvbnN0cnVjdE1vZGVsRGF0YVNvdXJjZVN0cmF0ZWd5LFxuKTogQ29uc3RydWN0Q3VzdG9tU3FsRGF0YVNvdXJjZVN0cmF0ZWd5W10gPT4ge1xuICBpZiAoIWlzU3FsU3RyYXRlZ3koZGF0YVNvdXJjZVN0cmF0ZWd5KSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IHBhcnNlZFNjaGVtYSA9IHBhcnNlKHNjaGVtYSk7XG5cbiAgY29uc3QgcXVlcnlOb2RlID0gcGFyc2VkU2NoZW1hLmRlZmluaXRpb25zLmZpbmQoaXNRdWVyeU5vZGUpO1xuICBjb25zdCBtdXRhdGlvbk5vZGUgPSBwYXJzZWRTY2hlbWEuZGVmaW5pdGlvbnMuZmluZChpc011dGF0aW9uTm9kZSk7XG4gIGlmICghcXVlcnlOb2RlICYmICFtdXRhdGlvbk5vZGUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBjdXN0b21TcWxEYXRhU291cmNlU3RyYXRlZ2llczogQ29uc3RydWN0Q3VzdG9tU3FsRGF0YVNvdXJjZVN0cmF0ZWd5W10gPSBbXTtcblxuICBpZiAocXVlcnlOb2RlKSB7XG4gICAgY29uc3QgZmllbGRzID0gZmllbGRzV2l0aFNxbERpcmVjdGl2ZShxdWVyeU5vZGUpO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICBjdXN0b21TcWxEYXRhU291cmNlU3RyYXRlZ2llcy5wdXNoKHtcbiAgICAgICAgdHlwZU5hbWU6ICdRdWVyeScsXG4gICAgICAgIGZpZWxkTmFtZTogZmllbGQubmFtZS52YWx1ZSxcbiAgICAgICAgc3RyYXRlZ3k6IGRhdGFTb3VyY2VTdHJhdGVneSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXRhdGlvbk5vZGUpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBmaWVsZHNXaXRoU3FsRGlyZWN0aXZlKG11dGF0aW9uTm9kZSk7XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgIGN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVnaWVzLnB1c2goe1xuICAgICAgICB0eXBlTmFtZTogJ011dGF0aW9uJyxcbiAgICAgICAgZmllbGROYW1lOiBmaWVsZC5uYW1lLnZhbHVlLFxuICAgICAgICBzdHJhdGVneTogZGF0YVNvdXJjZVN0cmF0ZWd5LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN1c3RvbVNxbERhdGFTb3VyY2VTdHJhdGVnaWVzO1xufTtcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgZGF0YSBzb3VyY2UgcHJvdmlkZXIgZnJvbSB0aGUgZGVmaW5pdGlvbi4gVGhpcyBqdW1wcyB0aHJvdWdoIHNvbWUgaG9vcHMgdG8gYXZvaWQgY2hhbmdpbmcgdGhlIHB1YmxpYyBpbnRlcmZhY2UuIElmIHdlIGRlY2lkZVxuICogdG8gY2hhbmdlIHRoZSBwdWJsaWMgaW50ZXJmYWNlIHRvIHNpbXBsaWZ5IHRoZSBzdHJ1Y3R1cmUsIHRoZW4gdGhpcyBwcm9jZXNzIGdldHMgYSBsb3Qgc2ltcGxlci5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldERhdGFTb3VyY2VTdHJhdGVnaWVzUHJvdmlkZXIgPSAoZGVmaW5pdGlvbjogSUFtcGxpZnlHcmFwaHFsRGVmaW5pdGlvbik6IERhdGFTb3VyY2VTdHJhdGVnaWVzUHJvdmlkZXIgPT4ge1xuICBjb25zdCBwcm92aWRlcjogRGF0YVNvdXJjZVN0cmF0ZWdpZXNQcm92aWRlciA9IHtcbiAgICAvLyBXZSBjYW4gZGlyZWN0bHkgdXNlIHRoZSBpbnRlcmZhY2Ugc3RyYXRlZ2llcywgZXZlbiB0aG91Z2ggdGhlIFNRTCBzdHJhdGVnaWVzIGhhdmUgdGhlIGN1c3RvbVNxbFN0YXRlbWVudHMgZmllbGQgdGhhdCBpcyB1bnVzZWQgYnkgdGhlXG4gICAgLy8gdHJhbnNmb3JtZXIgZmxhdm9yIG9mIHRoaXMgdHlwZVxuICAgIGRhdGFTb3VyY2VTdHJhdGVnaWVzOiBkZWZpbml0aW9uLmRhdGFTb3VyY2VTdHJhdGVnaWVzLFxuICAgIHNxbERpcmVjdGl2ZURhdGFTb3VyY2VTdHJhdGVnaWVzOiBbXSxcbiAgfTtcblxuICAvLyBXZSdsbCBjb2xsZWN0IGFsbCB0aGUgY3VzdG9tIFNRTCBzdGF0ZW1lbnRzIGZyb20gdGhlIGRlZmluaXRpb24gaW50byBhIHNpbmdsZSBtYXAsIGFuZCB1c2UgdGhhdCB0byBtYWtlIG91clxuICAvLyBTcWxEaXJlY3RpdmVEYXRhU291cmNlU3RyYXRlZ2llc1xuICBjb25zdCBjdXN0b21TcWxTdGF0ZW1lbnRzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgY29uc3QgY29uc3RydWN0U3FsU3RyYXRlZ2llcyA9IGRlZmluaXRpb24uY3VzdG9tU3FsRGF0YVNvdXJjZVN0cmF0ZWdpZXMgPz8gW107XG5cbiAgLy8gTm90ZSB0aGF0IHdlJ3JlIHJlbHlpbmcgb24gdGhlIGBjdXN0b21TcWxTdGF0ZW1lbnRzYCBvYmplY3QgcmVmZXJlbmNlIHRvIHN0YXkgdGhlIHNhbWUgdGhyb3VnaG91dCB0aGlzIGxvb3AuIERvbid0IHJlYXNzaWduIGl0LCBvciB0aGVcbiAgLy8gY29sbGVjdGVkIHNxbERpcmVjdGl2ZVN0cmF0ZWdpZXMgd2lsbCBicmVha1xuICBjb25zdHJ1Y3RTcWxTdHJhdGVnaWVzLmZvckVhY2goKHNxbFN0cmF0ZWd5KSA9PiB7XG4gICAgaWYgKHNxbFN0cmF0ZWd5LnN0cmF0ZWd5LmN1c3RvbVNxbFN0YXRlbWVudHMpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oY3VzdG9tU3FsU3RhdGVtZW50cywgc3FsU3RyYXRlZ3kuc3RyYXRlZ3kuY3VzdG9tU3FsU3RhdGVtZW50cyk7XG4gICAgfVxuXG4gICAgcHJvdmlkZXIuc3FsRGlyZWN0aXZlRGF0YVNvdXJjZVN0cmF0ZWdpZXMhLnB1c2goe1xuICAgICAgdHlwZU5hbWU6IHNxbFN0cmF0ZWd5LnR5cGVOYW1lLFxuICAgICAgZmllbGROYW1lOiBzcWxTdHJhdGVneS5maWVsZE5hbWUsXG4gICAgICBzdHJhdGVneTogc3FsU3RyYXRlZ3kuc3RyYXRlZ3ksXG4gICAgICBjdXN0b21TcWxTdGF0ZW1lbnRzLFxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gcHJvdmlkZXI7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc2NoZW1hIGJ5IG1lcmdpbmcgdGhlIGluZGl2aWR1YWwgc2NoZW1hcyBjb250YWluZWQgaW4gdGhlIGRlZmluaXRpb25zLCBjb21iaW5pbmcgZmllbGRzIG9mIHRoZSBRdWVyeSBhbmQgTXV0YXRpb24gdHlwZXMgaW5cbiAqIGluZGl2aWR1YWwgZGVmaW5pdGlvbnMgaW50byBhIHNpbmdsZSBjb21iaW5lZCBkZWZpbml0aW9uLiBBZGRpbmcgZGlyZWN0aXZlcyB0byBgUXVlcnlgIGFuZCBgTXV0YXRpb25gIHR5cGVzIHBhcnRpY2lwYXRpbmcgaW4gYVxuICogY29tYmluYXRpb24gaXMgbm90IHN1cHBvcnRlZCAodGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZCB3aGV0aGVyIHRob3NlIGRpcmVjdGl2ZXMgYXJlIG1pZ3JhdGVkKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNjaGVtYUJ5TWVyZ2luZ0RlZmluaXRpb25zID0gKGRlZmluaXRpb25zOiBJQW1wbGlmeUdyYXBocWxEZWZpbml0aW9uW10pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBzY2hlbWEgPSBkZWZpbml0aW9ucy5tYXAoKGRlZikgPT4gZGVmLnNjaGVtYSkuam9pbignXFxuJyk7XG4gIGNvbnN0IHBhcnNlZFNjaGVtYSA9IHBhcnNlKHNjaGVtYSk7XG5cbiAgLy8gV2Ugc3RvcmUgdGhlIFF1ZXJ5ICYgTXV0YXRpb24gZGVmaW5pdGlvbnMgc2VwYXJhdGVseS4gU2luY2UgdGhlIGludGVyZmFjZXMgYXJlIHJlYWRvbmx5LCB3ZSdsbCBoYXZlIHRvIHJlLWNvbXBvc2UgdGhlIHR5cGVzIGFmdGVyIHdlJ3ZlXG4gIC8vIGNvbGxlY3RlZCBhbGwgdGhlIGZpZWxkc1xuICBjb25zdCBxdWVyeUFuZE11dGF0aW9uRGVmaW5pdGlvbnM6IFJlY29yZDxcbiAgICBzdHJpbmcsXG4gICAge1xuICAgICAgbm9kZTogT2JqZWN0VHlwZURlZmluaXRpb25Ob2RlIHwgSW50ZXJmYWNlVHlwZURlZmluaXRpb25Ob2RlO1xuICAgICAgZmllbGRzOiBGaWVsZERlZmluaXRpb25Ob2RlW107XG4gICAgfVxuICA+ID0ge307XG5cbiAgLy8gVGhyb3dzIGlmIHRoZSBmaWVsZCBoYXMgYWxyZWFkeSBiZWVuIGVuY291bnRlcmVkXG4gIGNvbnN0IHZhbGlkYXRlRmllbGQgPSAodHlwZU5hbWU6IHN0cmluZywgZmllbGROYW1lOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICBjb25zdCBmaWVsZHMgPSBxdWVyeUFuZE11dGF0aW9uRGVmaW5pdGlvbnNbdHlwZU5hbWVdPy5maWVsZHM7XG4gICAgaWYgKCFmaWVsZHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQubmFtZS52YWx1ZSA9PT0gZmllbGROYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlIGN1c3RvbSAke3R5cGVOYW1lfSBmaWVsZCAnJHtmaWVsZE5hbWV9JyB3YXMgZm91bmQgaW4gbXVsdGlwbGUgZGVmaW5pdGlvbnMsIGJ1dCBhIGZpZWxkIG5hbWUgY2Fubm90IGJlIHNoYXJlZCBiZXR3ZWVuIGRlZmluaXRpb25zLmAsXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvLyBUcmFuc2Zvcm0gdGhlIHNjaGVtYSBieSByZWR1Y2luZyBNdXRhdGlvbiAmIFF1ZXJ5IHR5cGVzOlxuICAvLyAtIENvbGxlY3QgTXV0YXRpb24gYW5kIFF1ZXJ5IGRlZmluaXRpb25zXG4gIC8vIC0gQWx0ZXIgdGhlIHBhcnNlZCBzY2hlbWEgYnkgZmlsdGVyaW5nIG91dCBNdXRhdGlvbiAmIFF1ZXJ5IHR5cGVzXG4gIC8vIC0gQWRkIHRoZSBjb21iaW5lZCBNdXRhdGlvbiAmIFF1ZXJ5IGRlZmluaXRpb25zIHRvIHRoZSBmaWx0ZXJlZCBzY2hlbWFcbiAgcGFyc2VkU2NoZW1hLmRlZmluaXRpb25zLmZpbHRlcihpc0J1aWx0SW5HcmFwaHFsTm9kZSkuZm9yRWFjaCgoZGVmKSA9PiB7XG4gICAgY29uc3QgdHlwZU5hbWUgPSBkZWYubmFtZS52YWx1ZTtcbiAgICBpZiAoIXF1ZXJ5QW5kTXV0YXRpb25EZWZpbml0aW9uc1t0eXBlTmFtZV0pIHtcbiAgICAgIHF1ZXJ5QW5kTXV0YXRpb25EZWZpbml0aW9uc1t0eXBlTmFtZV0gPSB7XG4gICAgICAgIG5vZGU6IGRlZixcbiAgICAgICAgLy8gYE9iamVjdFR5cGVEZWZpbml0aW9uTm9kZS5maWVsZHNgIGlzIGEgUmVhZG9ubHlBcnJheTsgc28gd2UgaGF2ZSB0byBjcmVhdGUgYSBuZXcgbXV0YWJsZSBhcnJheSB0byBjb2xsZWN0IGFsbCB0aGUgZmllbGRzXG4gICAgICAgIGZpZWxkczogWy4uLihkZWYuZmllbGRzID8/IFtdKV0sXG4gICAgICB9O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIChkZWYuZmllbGRzID8/IFtdKS5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgdmFsaWRhdGVGaWVsZCh0eXBlTmFtZSwgZmllbGQubmFtZS52YWx1ZSk7XG4gICAgfSk7XG5cbiAgICBxdWVyeUFuZE11dGF0aW9uRGVmaW5pdGlvbnNbdHlwZU5hbWVdLmZpZWxkcyA9IFsuLi5xdWVyeUFuZE11dGF0aW9uRGVmaW5pdGlvbnNbdHlwZU5hbWVdLmZpZWxkcywgLi4uKGRlZi5maWVsZHMgPz8gW10pXTtcbiAgfSk7XG5cbiAgLy8gR2F0aGVyIHRoZSBjb2xsZWN0ZWQgUXVlcnkgJiBNdXRhdGlvbiBmaWVsZHMgaW50byA8PTIgbmV3IGRlZmluaXRpb25zXG4gIGNvbnN0IGNvbWJpbmVkRGVmaW5pdGlvbnMgPSBPYmplY3QudmFsdWVzKHF1ZXJ5QW5kTXV0YXRpb25EZWZpbml0aW9ucylcbiAgICAuc29ydCgoYSwgYikgPT4gYS5ub2RlLm5hbWUudmFsdWUubG9jYWxlQ29tcGFyZShiLm5vZGUubmFtZS52YWx1ZSkpXG4gICAgLnJlZHVjZSgoYWNjLCBjdXIpID0+IHtcbiAgICAgIGNvbnN0IGRlZmluaXRpb25Ob2RlID0ge1xuICAgICAgICAuLi5jdXIubm9kZSxcbiAgICAgICAgZmllbGRzOiBjdXIuZmllbGRzLFxuICAgICAgfTtcbiAgICAgIHJldHVybiBbLi4uYWNjLCBkZWZpbml0aW9uTm9kZV07XG4gICAgfSwgW10gYXMgRGVmaW5pdGlvbk5vZGVbXSk7XG5cbiAgLy8gRmlsdGVyIG91dCB0aGUgb2xkIFF1ZXJ5ICYgTXV0YXRpb24gZGVmaW5pdGlvbnNcbiAgY29uc3QgZmlsdGVyZWREZWZpbml0aW9ucyA9IHBhcnNlZFNjaGVtYS5kZWZpbml0aW9ucy5maWx0ZXIoKGRlZikgPT4gIWlzQnVpbHRJbkdyYXBocWxOb2RlKGRlZikpO1xuXG4gIC8vIENvbXBvc2UgdGhlIG5ldyBzY2hlbWEgYnkgYXBwZW5kaW5nIHRoZSBjb2xsZWN0ZWQgZGVmaW5pdGlvbnMgdG8gdGhlIGZpbHRlcmVkIGRlZmluaXRpb25zLiBUaGlzIG1lYW5zIHRoYXQgZXZlcnkgcXVlcnkgd2lsbCBiZVxuICAvLyByZXdyaXR0ZW4gc3VjaCB0aGF0IHRoZSBNdXRhdGlvbiBhbmQgUXVlcnkgdHlwZXMgYXBwZWFyIGF0IHRoZSBlbmQgb2YgdGhlIHNjaGVtYS5cbiAgY29uc3QgbmV3U2NoZW1hID0ge1xuICAgIC4uLnBhcnNlZFNjaGVtYSxcbiAgICBkZWZpbml0aW9uczogWy4uLmZpbHRlcmVkRGVmaW5pdGlvbnMsIC4uLmNvbWJpbmVkRGVmaW5pdGlvbnNdLFxuICB9O1xuXG4gIGNvbnN0IGNvbWJpbmVkU2NoZW1hU3RyaW5nID0gcHJpbnQobmV3U2NoZW1hKTtcbiAgcmV0dXJuIGNvbWJpbmVkU2NoZW1hU3RyaW5nO1xufTtcblxuLypcbiAqIFZhbGlkYXRlcyB0aGUgdXNlciBpbnB1dCBmb3IgdGhlIGRhdGFTb3VyY2VTdHJhdGVneS4gVGhpcyBpcyBhIG5vLW9wIGZvciBEeW5hbW9EQiBzdHJhdGVnaWVzIGZvciBub3cuXG4gKiBAcGFyYW0gc3RyYXRlZ3kgdXNlciBwcm92aWRlZCBtb2RlbCBkYXRhIHNvdXJjZSBzdHJhdGVneVxuICogQHJldHVybnMgdmFsaWRhdGVzIGFuZCB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlIHN0cmF0ZWd5IGlzIGludmFsaWRcbiAqL1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRlRGF0YVNvdXJjZVN0cmF0ZWd5ID0gKHN0cmF0ZWd5OiBDb25zdHJ1Y3RNb2RlbERhdGFTb3VyY2VTdHJhdGVneSkgPT4ge1xuICBpZiAoIWlzU3FsU3RyYXRlZ3koc3RyYXRlZ3kpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZGJDb25uZWN0aW9uQ29uZmlnID0gc3RyYXRlZ3kuZGJDb25uZWN0aW9uQ29uZmlnO1xuICBjb25zdCBpbnZhbGlkU1NNUGF0aHMgPSBPYmplY3QudmFsdWVzKGRiQ29ubmVjdGlvbkNvbmZpZykuZmlsdGVyKCh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhaXNWYWxpZFNTTVBhdGgodmFsdWUpKTtcbiAgaWYgKGludmFsaWRTU01QYXRocy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgZGF0YSBzb3VyY2Ugc3RyYXRlZ3kgXCIke1xuICAgICAgICBzdHJhdGVneS5uYW1lXG4gICAgICB9XCIuIEZvbGxvd2luZyBTU00gcGF0aHMgbXVzdCBzdGFydCB3aXRoICcvJyBpbiBkYkNvbm5lY3Rpb25Db25maWc6ICR7aW52YWxpZFNTTVBhdGhzLmpvaW4oJywgJyl9LmAsXG4gICAgKTtcbiAgfVxufTtcblxuY29uc3QgaXNWYWxpZFNTTVBhdGggPSAocGF0aDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIHJldHVybiBwYXRoLnN0YXJ0c1dpdGgoJy8nKTtcbn07XG4iXX0=