import { AmplifyDataDefinition, } from '@aws-amplify/data-construct';
/**
 * Determine if the input schema is a derived model schema, and perform type narrowing.
 * @param schema the schema that might be a derived model schema
 * @returns a boolean indicating whether the schema is a derived model schema, with type narrowing
 */
const isModelSchema = (schema) => {
    return (schema !== null &&
        typeof schema === 'object' &&
        typeof schema.transform === 'function');
};
/**
 * Given an input schema type, produce the relevant CDK Graphql Def interface
 * @param schema the input schema type
 * @returns the cdk graphql definition interface
 */
export const convertSchemaToCDK = (schema) => {
    // DO NOT EDIT THE FOLLOWING VALUES, UPDATES TO DB TYPE OR STRATEGY WILL RESULT IN DB REPROVISIONING
    const dbType = 'DYNAMODB';
    const provisionStrategy = 'AMPLIFY_TABLE';
    if (isModelSchema(schema)) {
        /**
         * This is not super obvious, but the IAmplifyDataDefinition interface requires a record of each model type to a
         * data source strategy (how it should be deployed and managed). Normally this is handled for customers by static
         * methods on AmplifyDataDefinition, but since the data-schema-types don't produce that today, we use the builder
         * to generate that argument for us (so it's consistent with a customer using normal Graphql strings), then
         * apply that value back into the final IAmplifyDataDefinition output for data-schema users.
         */
        const generatedModelDataSourceStrategies = AmplifyDataDefinition.fromString(schema.transform().schema, {
            dbType,
            provisionStrategy,
        }).dataSourceStrategies;
        return {
            ...schema.transform(),
            dataSourceStrategies: generatedModelDataSourceStrategies,
        };
    }
    return AmplifyDataDefinition.fromString(schema, {
        dbType,
        provisionStrategy,
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVydF9zY2hlbWEuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvY29udmVydF9zY2hlbWEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUNMLHFCQUFxQixHQUV0QixNQUFNLDZCQUE2QixDQUFDO0FBR3JDOzs7O0dBSUc7QUFDSCxNQUFNLGFBQWEsR0FBRyxDQUFDLE1BQWtCLEVBQWdDLEVBQUU7SUFDekUsT0FBTyxDQUNMLE1BQU0sS0FBSyxJQUFJO1FBQ2YsT0FBTyxNQUFNLEtBQUssUUFBUTtRQUMxQixPQUFPLE1BQU0sQ0FBQyxTQUFTLEtBQUssVUFBVSxDQUN2QyxDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBRUY7Ozs7R0FJRztBQUNILE1BQU0sQ0FBQyxNQUFNLGtCQUFrQixHQUFHLENBQ2hDLE1BQWtCLEVBQ00sRUFBRTtJQUMxQixvR0FBb0c7SUFDcEcsTUFBTSxNQUFNLEdBQUcsVUFBVSxDQUFDO0lBQzFCLE1BQU0saUJBQWlCLEdBQUcsZUFBZSxDQUFDO0lBRTFDLElBQUksYUFBYSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1FBQ3pCOzs7Ozs7V0FNRztRQUNILE1BQU0sa0NBQWtDLEdBQUcscUJBQXFCLENBQUMsVUFBVSxDQUN6RSxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUMsTUFBTSxFQUN6QjtZQUNFLE1BQU07WUFDTixpQkFBaUI7U0FDbEIsQ0FDRixDQUFDLG9CQUFvQixDQUFDO1FBQ3ZCLE9BQU87WUFDTCxHQUFHLE1BQU0sQ0FBQyxTQUFTLEVBQUU7WUFDckIsb0JBQW9CLEVBQUUsa0NBQWtDO1NBQ3pELENBQUM7S0FDSDtJQUVELE9BQU8scUJBQXFCLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRTtRQUM5QyxNQUFNO1FBQ04saUJBQWlCO0tBQ2xCLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERlcml2ZWRNb2RlbFNjaGVtYSB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9kYXRhLXNjaGVtYS10eXBlcyc7XG5pbXBvcnQge1xuICBBbXBsaWZ5RGF0YURlZmluaXRpb24sXG4gIElBbXBsaWZ5RGF0YURlZmluaXRpb24sXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9kYXRhLWNvbnN0cnVjdCc7XG5pbXBvcnQgeyBEYXRhU2NoZW1hIH0gZnJvbSAnLi90eXBlcy5qcyc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBpbnB1dCBzY2hlbWEgaXMgYSBkZXJpdmVkIG1vZGVsIHNjaGVtYSwgYW5kIHBlcmZvcm0gdHlwZSBuYXJyb3dpbmcuXG4gKiBAcGFyYW0gc2NoZW1hIHRoZSBzY2hlbWEgdGhhdCBtaWdodCBiZSBhIGRlcml2ZWQgbW9kZWwgc2NoZW1hXG4gKiBAcmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzY2hlbWEgaXMgYSBkZXJpdmVkIG1vZGVsIHNjaGVtYSwgd2l0aCB0eXBlIG5hcnJvd2luZ1xuICovXG5jb25zdCBpc01vZGVsU2NoZW1hID0gKHNjaGVtYTogRGF0YVNjaGVtYSk6IHNjaGVtYSBpcyBEZXJpdmVkTW9kZWxTY2hlbWEgPT4ge1xuICByZXR1cm4gKFxuICAgIHNjaGVtYSAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiBzY2hlbWEgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHNjaGVtYS50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbidcbiAgKTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gaW5wdXQgc2NoZW1hIHR5cGUsIHByb2R1Y2UgdGhlIHJlbGV2YW50IENESyBHcmFwaHFsIERlZiBpbnRlcmZhY2VcbiAqIEBwYXJhbSBzY2hlbWEgdGhlIGlucHV0IHNjaGVtYSB0eXBlXG4gKiBAcmV0dXJucyB0aGUgY2RrIGdyYXBocWwgZGVmaW5pdGlvbiBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRTY2hlbWFUb0NESyA9IChcbiAgc2NoZW1hOiBEYXRhU2NoZW1hXG4pOiBJQW1wbGlmeURhdGFEZWZpbml0aW9uID0+IHtcbiAgLy8gRE8gTk9UIEVESVQgVEhFIEZPTExPV0lORyBWQUxVRVMsIFVQREFURVMgVE8gREIgVFlQRSBPUiBTVFJBVEVHWSBXSUxMIFJFU1VMVCBJTiBEQiBSRVBST1ZJU0lPTklOR1xuICBjb25zdCBkYlR5cGUgPSAnRFlOQU1PREInO1xuICBjb25zdCBwcm92aXNpb25TdHJhdGVneSA9ICdBTVBMSUZZX1RBQkxFJztcblxuICBpZiAoaXNNb2RlbFNjaGVtYShzY2hlbWEpKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBub3Qgc3VwZXIgb2J2aW91cywgYnV0IHRoZSBJQW1wbGlmeURhdGFEZWZpbml0aW9uIGludGVyZmFjZSByZXF1aXJlcyBhIHJlY29yZCBvZiBlYWNoIG1vZGVsIHR5cGUgdG8gYVxuICAgICAqIGRhdGEgc291cmNlIHN0cmF0ZWd5IChob3cgaXQgc2hvdWxkIGJlIGRlcGxveWVkIGFuZCBtYW5hZ2VkKS4gTm9ybWFsbHkgdGhpcyBpcyBoYW5kbGVkIGZvciBjdXN0b21lcnMgYnkgc3RhdGljXG4gICAgICogbWV0aG9kcyBvbiBBbXBsaWZ5RGF0YURlZmluaXRpb24sIGJ1dCBzaW5jZSB0aGUgZGF0YS1zY2hlbWEtdHlwZXMgZG9uJ3QgcHJvZHVjZSB0aGF0IHRvZGF5LCB3ZSB1c2UgdGhlIGJ1aWxkZXJcbiAgICAgKiB0byBnZW5lcmF0ZSB0aGF0IGFyZ3VtZW50IGZvciB1cyAoc28gaXQncyBjb25zaXN0ZW50IHdpdGggYSBjdXN0b21lciB1c2luZyBub3JtYWwgR3JhcGhxbCBzdHJpbmdzKSwgdGhlblxuICAgICAqIGFwcGx5IHRoYXQgdmFsdWUgYmFjayBpbnRvIHRoZSBmaW5hbCBJQW1wbGlmeURhdGFEZWZpbml0aW9uIG91dHB1dCBmb3IgZGF0YS1zY2hlbWEgdXNlcnMuXG4gICAgICovXG4gICAgY29uc3QgZ2VuZXJhdGVkTW9kZWxEYXRhU291cmNlU3RyYXRlZ2llcyA9IEFtcGxpZnlEYXRhRGVmaW5pdGlvbi5mcm9tU3RyaW5nKFxuICAgICAgc2NoZW1hLnRyYW5zZm9ybSgpLnNjaGVtYSxcbiAgICAgIHtcbiAgICAgICAgZGJUeXBlLFxuICAgICAgICBwcm92aXNpb25TdHJhdGVneSxcbiAgICAgIH1cbiAgICApLmRhdGFTb3VyY2VTdHJhdGVnaWVzO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zY2hlbWEudHJhbnNmb3JtKCksXG4gICAgICBkYXRhU291cmNlU3RyYXRlZ2llczogZ2VuZXJhdGVkTW9kZWxEYXRhU291cmNlU3RyYXRlZ2llcyxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIEFtcGxpZnlEYXRhRGVmaW5pdGlvbi5mcm9tU3RyaW5nKHNjaGVtYSwge1xuICAgIGRiVHlwZSxcbiAgICBwcm92aXNpb25TdHJhdGVneSxcbiAgfSk7XG59O1xuIl19