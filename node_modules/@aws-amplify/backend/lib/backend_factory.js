import { NestedStackResolver, } from './engine/nested_stack_resolver.js';
import { SingletonConstructContainer } from './engine/singleton_construct_container.js';
import { ToggleableImportPathVerifier } from './engine/toggleable_import_path_verifier.js';
import { AttributionMetadataStorage, StackMetadataBackendOutputStorageStrategy, } from '@aws-amplify/backend-output-storage';
import { createDefaultStack } from './default_stack_factory.js';
import { getBackendIdentifier } from './backend_identifier.js';
import { platformOutputKey } from '@aws-amplify/backend-output-schemas';
import { fileURLToPath } from 'url';
import { AmplifyBranchLinkerConstruct } from './engine/branch-linker/branch_linker_construct.js';
import { CustomOutputsAccumulator } from './engine/custom_outputs_accumulator.js';
import { ObjectAccumulator } from '@aws-amplify/platform-core';
// Be very careful editing this value. It is the value used in the BI metrics to attribute stacks as Amplify root stacks
const rootStackTypeIdentifier = 'root';
/**
 * Factory that collects and instantiates all the Amplify backend constructs
 */
export class BackendFactory {
    /**
     * These are the resolved CDK constructs that are created by the inputs to the constructor
     * Used for overriding properties of underlying CDK constructs or to reference in custom CDK code
     */
    resources;
    stackResolver;
    customOutputsAccumulator;
    /**
     * Initialize an Amplify backend with the given construct factories and in the given CDK App.
     * If no CDK App is specified a new one is created
     */
    constructor(constructFactories, stack = createDefaultStack()) {
        new AttributionMetadataStorage().storeAttributionMetadata(stack, rootStackTypeIdentifier, fileURLToPath(new URL('../package.json', import.meta.url)));
        this.stackResolver = new NestedStackResolver(stack, new AttributionMetadataStorage());
        const constructContainer = new SingletonConstructContainer(this.stackResolver);
        const outputStorageStrategy = new StackMetadataBackendOutputStorageStrategy(stack);
        this.customOutputsAccumulator = new CustomOutputsAccumulator(outputStorageStrategy, new ObjectAccumulator({}));
        const backendId = getBackendIdentifier(stack);
        outputStorageStrategy.addBackendOutputEntry(platformOutputKey, {
            version: '1',
            payload: {
                deploymentType: backendId.type,
                region: stack.region,
            },
        });
        const shouldEnableBranchLinker = backendId.type === 'branch';
        if (shouldEnableBranchLinker) {
            new AmplifyBranchLinkerConstruct(stack, backendId);
        }
        const importPathVerifier = new ToggleableImportPathVerifier();
        // register providers but don't actually execute anything yet
        Object.values(constructFactories).forEach((factory) => {
            if (typeof factory.provides === 'string') {
                constructContainer.registerConstructFactory(factory.provides, factory);
            }
        });
        // now invoke all the factories and collect the constructs into this.resources
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.resources = {};
        Object.entries(constructFactories).forEach(([resourceName, constructFactory]) => {
            // The type inference on this.resources is not happy about this assignment because it doesn't know the exact type of .getInstance()
            // However, the assignment is okay because we are iterating over the entries of constructFactories and assigning the resource name to the corresponding instance
            this.resources[resourceName] = constructFactory.getInstance({
                constructContainer,
                outputStorageStrategy,
                importPathVerifier,
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            );
        });
    }
    /**
     * Returns a CDK stack within the Amplify project that can be used for creating custom resources.
     * If a stack has already been created with "name" then an error is thrown.
     */
    createStack = (name) => {
        return this.stackResolver.createCustomStack(name);
    };
    addOutput = (clientConfigPart) => this.customOutputsAccumulator.addOutput(clientConfigPart);
}
/**
 * Creates a new Amplify backend instance and returns it
 * @param constructFactories - list of backend factories such as those created by `defineAuth` or `defineData`
 */
export const defineBackend = (constructFactories) => {
    const backend = new BackendFactory(constructFactories);
    return {
        ...backend.resources,
        createStack: backend.createStack,
        addOutput: backend.addOutput,
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZF9mYWN0b3J5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2JhY2tlbmRfZmFjdG9yeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEVBQ0wsbUJBQW1CLEdBRXBCLE1BQU0sbUNBQW1DLENBQUM7QUFDM0MsT0FBTyxFQUFFLDJCQUEyQixFQUFFLE1BQU0sMkNBQTJDLENBQUM7QUFDeEYsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0sNkNBQTZDLENBQUM7QUFDM0YsT0FBTyxFQUNMLDBCQUEwQixFQUMxQix5Q0FBeUMsR0FDMUMsTUFBTSxxQ0FBcUMsQ0FBQztBQUM3QyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUNoRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUMvRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUN4RSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sS0FBSyxDQUFDO0FBRXBDLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLG1EQUFtRCxDQUFDO0FBRWpHLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQ2xGLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBRS9ELHdIQUF3SDtBQUN4SCxNQUFNLHVCQUF1QixHQUFHLE1BQU0sQ0FBQztBQUV2Qzs7R0FFRztBQUNILE1BQU0sT0FBTyxjQUFjO0lBR3pCOzs7T0FHRztJQUNNLFNBQVMsQ0FFaEI7SUFFZSxhQUFhLENBQWdCO0lBQzdCLHdCQUF3QixDQUEyQjtJQUNwRTs7O09BR0c7SUFDSCxZQUFZLGtCQUFxQixFQUFFLFFBQWUsa0JBQWtCLEVBQUU7UUFDcEUsSUFBSSwwQkFBMEIsRUFBRSxDQUFDLHdCQUF3QixDQUN2RCxLQUFLLEVBQ0wsdUJBQXVCLEVBQ3ZCLGFBQWEsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxpQkFBaUIsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQzNELENBQUM7UUFDRixJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksbUJBQW1CLENBQzFDLEtBQUssRUFDTCxJQUFJLDBCQUEwQixFQUFFLENBQ2pDLENBQUM7UUFFRixNQUFNLGtCQUFrQixHQUFHLElBQUksMkJBQTJCLENBQ3hELElBQUksQ0FBQyxhQUFhLENBQ25CLENBQUM7UUFFRixNQUFNLHFCQUFxQixHQUFHLElBQUkseUNBQXlDLENBQ3pFLEtBQUssQ0FDTixDQUFDO1FBRUYsSUFBSSxDQUFDLHdCQUF3QixHQUFHLElBQUksd0JBQXdCLENBQzFELHFCQUFxQixFQUNyQixJQUFJLGlCQUFpQixDQUFlLEVBQUUsQ0FBQyxDQUN4QyxDQUFDO1FBRUYsTUFBTSxTQUFTLEdBQUcsb0JBQW9CLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDOUMscUJBQXFCLENBQUMscUJBQXFCLENBQUMsaUJBQWlCLEVBQUU7WUFDN0QsT0FBTyxFQUFFLEdBQUc7WUFDWixPQUFPLEVBQUU7Z0JBQ1AsY0FBYyxFQUFFLFNBQVMsQ0FBQyxJQUFJO2dCQUM5QixNQUFNLEVBQUUsS0FBSyxDQUFDLE1BQU07YUFDckI7U0FDRixDQUFDLENBQUM7UUFFSCxNQUFNLHdCQUF3QixHQUFHLFNBQVMsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDO1FBRTdELElBQUksd0JBQXdCLEVBQUU7WUFDNUIsSUFBSSw0QkFBNEIsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLENBQUM7U0FDcEQ7UUFFRCxNQUFNLGtCQUFrQixHQUFHLElBQUksNEJBQTRCLEVBQUUsQ0FBQztRQUU5RCw2REFBNkQ7UUFDN0QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFO1lBQ3BELElBQUksT0FBTyxPQUFPLENBQUMsUUFBUSxLQUFLLFFBQVEsRUFBRTtnQkFDeEMsa0JBQWtCLENBQUMsd0JBQXdCLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQzthQUN4RTtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsOEVBQThFO1FBQzlFLDhEQUE4RDtRQUM5RCxJQUFJLENBQUMsU0FBUyxHQUFHLEVBQVMsQ0FBQztRQUMzQixNQUFNLENBQUMsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUMsT0FBTyxDQUN4QyxDQUFDLENBQUMsWUFBWSxFQUFFLGdCQUFnQixDQUFDLEVBQUUsRUFBRTtZQUNuQyxtSUFBbUk7WUFDbkksZ0tBQWdLO1lBQ2hLLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBdUIsQ0FBQyxHQUFHLGdCQUFnQixDQUFDLFdBQVcsQ0FDcEU7Z0JBQ0Usa0JBQWtCO2dCQUNsQixxQkFBcUI7Z0JBQ3JCLGtCQUFrQjthQUNuQjtZQUNELDhEQUE4RDthQUN4RCxDQUFDO1FBQ1gsQ0FBQyxDQUNGLENBQUM7SUFDSixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsV0FBVyxHQUFHLENBQUMsSUFBWSxFQUFTLEVBQUU7UUFDcEMsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BELENBQUMsQ0FBQztJQUVGLFNBQVMsR0FBRyxDQUFDLGdCQUF1QyxFQUFFLEVBQUUsQ0FDdEQsSUFBSSxDQUFDLHdCQUF3QixDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0NBQzdEO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sYUFBYSxHQUFHLENBQzNCLGtCQUFxQixFQUNULEVBQUU7SUFDZCxNQUFNLE9BQU8sR0FBRyxJQUFJLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQ3ZELE9BQU87UUFDTCxHQUFHLE9BQU8sQ0FBQyxTQUFTO1FBQ3BCLFdBQVcsRUFBRSxPQUFPLENBQUMsV0FBVztRQUNoQyxTQUFTLEVBQUUsT0FBTyxDQUFDLFNBQVM7S0FDN0IsQ0FBQztBQUNKLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnN0cnVjdEZhY3RvcnksIFJlc291cmNlUHJvdmlkZXIgfSBmcm9tICdAYXdzLWFtcGxpZnkvcGx1Z2luLXR5cGVzJztcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnYXdzLWNkay1saWInO1xuaW1wb3J0IHtcbiAgTmVzdGVkU3RhY2tSZXNvbHZlcixcbiAgU3RhY2tSZXNvbHZlcixcbn0gZnJvbSAnLi9lbmdpbmUvbmVzdGVkX3N0YWNrX3Jlc29sdmVyLmpzJztcbmltcG9ydCB7IFNpbmdsZXRvbkNvbnN0cnVjdENvbnRhaW5lciB9IGZyb20gJy4vZW5naW5lL3NpbmdsZXRvbl9jb25zdHJ1Y3RfY29udGFpbmVyLmpzJztcbmltcG9ydCB7IFRvZ2dsZWFibGVJbXBvcnRQYXRoVmVyaWZpZXIgfSBmcm9tICcuL2VuZ2luZS90b2dnbGVhYmxlX2ltcG9ydF9wYXRoX3ZlcmlmaWVyLmpzJztcbmltcG9ydCB7XG4gIEF0dHJpYnV0aW9uTWV0YWRhdGFTdG9yYWdlLFxuICBTdGFja01ldGFkYXRhQmFja2VuZE91dHB1dFN0b3JhZ2VTdHJhdGVneSxcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L2JhY2tlbmQtb3V0cHV0LXN0b3JhZ2UnO1xuaW1wb3J0IHsgY3JlYXRlRGVmYXVsdFN0YWNrIH0gZnJvbSAnLi9kZWZhdWx0X3N0YWNrX2ZhY3RvcnkuanMnO1xuaW1wb3J0IHsgZ2V0QmFja2VuZElkZW50aWZpZXIgfSBmcm9tICcuL2JhY2tlbmRfaWRlbnRpZmllci5qcyc7XG5pbXBvcnQgeyBwbGF0Zm9ybU91dHB1dEtleSB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9iYWNrZW5kLW91dHB1dC1zY2hlbWFzJztcbmltcG9ydCB7IGZpbGVVUkxUb1BhdGggfSBmcm9tICd1cmwnO1xuaW1wb3J0IHsgQmFja2VuZCwgRGVmaW5lQmFja2VuZFByb3BzIH0gZnJvbSAnLi9iYWNrZW5kLmpzJztcbmltcG9ydCB7IEFtcGxpZnlCcmFuY2hMaW5rZXJDb25zdHJ1Y3QgfSBmcm9tICcuL2VuZ2luZS9icmFuY2gtbGlua2VyL2JyYW5jaF9saW5rZXJfY29uc3RydWN0LmpzJztcbmltcG9ydCB7IENsaWVudENvbmZpZyB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9jbGllbnQtY29uZmlnJztcbmltcG9ydCB7IEN1c3RvbU91dHB1dHNBY2N1bXVsYXRvciB9IGZyb20gJy4vZW5naW5lL2N1c3RvbV9vdXRwdXRzX2FjY3VtdWxhdG9yLmpzJztcbmltcG9ydCB7IE9iamVjdEFjY3VtdWxhdG9yIH0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsYXRmb3JtLWNvcmUnO1xuXG4vLyBCZSB2ZXJ5IGNhcmVmdWwgZWRpdGluZyB0aGlzIHZhbHVlLiBJdCBpcyB0aGUgdmFsdWUgdXNlZCBpbiB0aGUgQkkgbWV0cmljcyB0byBhdHRyaWJ1dGUgc3RhY2tzIGFzIEFtcGxpZnkgcm9vdCBzdGFja3NcbmNvbnN0IHJvb3RTdGFja1R5cGVJZGVudGlmaWVyID0gJ3Jvb3QnO1xuXG4vKipcbiAqIEZhY3RvcnkgdGhhdCBjb2xsZWN0cyBhbmQgaW5zdGFudGlhdGVzIGFsbCB0aGUgQW1wbGlmeSBiYWNrZW5kIGNvbnN0cnVjdHNcbiAqL1xuZXhwb3J0IGNsYXNzIEJhY2tlbmRGYWN0b3J5PFxuICBUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgQ29uc3RydWN0RmFjdG9yeTxSZXNvdXJjZVByb3ZpZGVyPj5cbj4ge1xuICAvKipcbiAgICogVGhlc2UgYXJlIHRoZSByZXNvbHZlZCBDREsgY29uc3RydWN0cyB0aGF0IGFyZSBjcmVhdGVkIGJ5IHRoZSBpbnB1dHMgdG8gdGhlIGNvbnN0cnVjdG9yXG4gICAqIFVzZWQgZm9yIG92ZXJyaWRpbmcgcHJvcGVydGllcyBvZiB1bmRlcmx5aW5nIENESyBjb25zdHJ1Y3RzIG9yIHRvIHJlZmVyZW5jZSBpbiBjdXN0b20gQ0RLIGNvZGVcbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlczoge1xuICAgIFtLIGluIGtleW9mIFRdOiBSZXR1cm5UeXBlPFRbS11bJ2dldEluc3RhbmNlJ10+O1xuICB9O1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgc3RhY2tSZXNvbHZlcjogU3RhY2tSZXNvbHZlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBjdXN0b21PdXRwdXRzQWNjdW11bGF0b3I6IEN1c3RvbU91dHB1dHNBY2N1bXVsYXRvcjtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYW4gQW1wbGlmeSBiYWNrZW5kIHdpdGggdGhlIGdpdmVuIGNvbnN0cnVjdCBmYWN0b3JpZXMgYW5kIGluIHRoZSBnaXZlbiBDREsgQXBwLlxuICAgKiBJZiBubyBDREsgQXBwIGlzIHNwZWNpZmllZCBhIG5ldyBvbmUgaXMgY3JlYXRlZFxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uc3RydWN0RmFjdG9yaWVzOiBULCBzdGFjazogU3RhY2sgPSBjcmVhdGVEZWZhdWx0U3RhY2soKSkge1xuICAgIG5ldyBBdHRyaWJ1dGlvbk1ldGFkYXRhU3RvcmFnZSgpLnN0b3JlQXR0cmlidXRpb25NZXRhZGF0YShcbiAgICAgIHN0YWNrLFxuICAgICAgcm9vdFN0YWNrVHlwZUlkZW50aWZpZXIsXG4gICAgICBmaWxlVVJMVG9QYXRoKG5ldyBVUkwoJy4uL3BhY2thZ2UuanNvbicsIGltcG9ydC5tZXRhLnVybCkpXG4gICAgKTtcbiAgICB0aGlzLnN0YWNrUmVzb2x2ZXIgPSBuZXcgTmVzdGVkU3RhY2tSZXNvbHZlcihcbiAgICAgIHN0YWNrLFxuICAgICAgbmV3IEF0dHJpYnV0aW9uTWV0YWRhdGFTdG9yYWdlKClcbiAgICApO1xuXG4gICAgY29uc3QgY29uc3RydWN0Q29udGFpbmVyID0gbmV3IFNpbmdsZXRvbkNvbnN0cnVjdENvbnRhaW5lcihcbiAgICAgIHRoaXMuc3RhY2tSZXNvbHZlclxuICAgICk7XG5cbiAgICBjb25zdCBvdXRwdXRTdG9yYWdlU3RyYXRlZ3kgPSBuZXcgU3RhY2tNZXRhZGF0YUJhY2tlbmRPdXRwdXRTdG9yYWdlU3RyYXRlZ3koXG4gICAgICBzdGFja1xuICAgICk7XG5cbiAgICB0aGlzLmN1c3RvbU91dHB1dHNBY2N1bXVsYXRvciA9IG5ldyBDdXN0b21PdXRwdXRzQWNjdW11bGF0b3IoXG4gICAgICBvdXRwdXRTdG9yYWdlU3RyYXRlZ3ksXG4gICAgICBuZXcgT2JqZWN0QWNjdW11bGF0b3I8Q2xpZW50Q29uZmlnPih7fSlcbiAgICApO1xuXG4gICAgY29uc3QgYmFja2VuZElkID0gZ2V0QmFja2VuZElkZW50aWZpZXIoc3RhY2spO1xuICAgIG91dHB1dFN0b3JhZ2VTdHJhdGVneS5hZGRCYWNrZW5kT3V0cHV0RW50cnkocGxhdGZvcm1PdXRwdXRLZXksIHtcbiAgICAgIHZlcnNpb246ICcxJyxcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgZGVwbG95bWVudFR5cGU6IGJhY2tlbmRJZC50eXBlLFxuICAgICAgICByZWdpb246IHN0YWNrLnJlZ2lvbixcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBzaG91bGRFbmFibGVCcmFuY2hMaW5rZXIgPSBiYWNrZW5kSWQudHlwZSA9PT0gJ2JyYW5jaCc7XG5cbiAgICBpZiAoc2hvdWxkRW5hYmxlQnJhbmNoTGlua2VyKSB7XG4gICAgICBuZXcgQW1wbGlmeUJyYW5jaExpbmtlckNvbnN0cnVjdChzdGFjaywgYmFja2VuZElkKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbXBvcnRQYXRoVmVyaWZpZXIgPSBuZXcgVG9nZ2xlYWJsZUltcG9ydFBhdGhWZXJpZmllcigpO1xuXG4gICAgLy8gcmVnaXN0ZXIgcHJvdmlkZXJzIGJ1dCBkb24ndCBhY3R1YWxseSBleGVjdXRlIGFueXRoaW5nIHlldFxuICAgIE9iamVjdC52YWx1ZXMoY29uc3RydWN0RmFjdG9yaWVzKS5mb3JFYWNoKChmYWN0b3J5KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGZhY3RvcnkucHJvdmlkZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0cnVjdENvbnRhaW5lci5yZWdpc3RlckNvbnN0cnVjdEZhY3RvcnkoZmFjdG9yeS5wcm92aWRlcywgZmFjdG9yeSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBub3cgaW52b2tlIGFsbCB0aGUgZmFjdG9yaWVzIGFuZCBjb2xsZWN0IHRoZSBjb25zdHJ1Y3RzIGludG8gdGhpcy5yZXNvdXJjZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHRoaXMucmVzb3VyY2VzID0ge30gYXMgYW55O1xuICAgIE9iamVjdC5lbnRyaWVzKGNvbnN0cnVjdEZhY3RvcmllcykuZm9yRWFjaChcbiAgICAgIChbcmVzb3VyY2VOYW1lLCBjb25zdHJ1Y3RGYWN0b3J5XSkgPT4ge1xuICAgICAgICAvLyBUaGUgdHlwZSBpbmZlcmVuY2Ugb24gdGhpcy5yZXNvdXJjZXMgaXMgbm90IGhhcHB5IGFib3V0IHRoaXMgYXNzaWdubWVudCBiZWNhdXNlIGl0IGRvZXNuJ3Qga25vdyB0aGUgZXhhY3QgdHlwZSBvZiAuZ2V0SW5zdGFuY2UoKVxuICAgICAgICAvLyBIb3dldmVyLCB0aGUgYXNzaWdubWVudCBpcyBva2F5IGJlY2F1c2Ugd2UgYXJlIGl0ZXJhdGluZyBvdmVyIHRoZSBlbnRyaWVzIG9mIGNvbnN0cnVjdEZhY3RvcmllcyBhbmQgYXNzaWduaW5nIHRoZSByZXNvdXJjZSBuYW1lIHRvIHRoZSBjb3JyZXNwb25kaW5nIGluc3RhbmNlXG4gICAgICAgIHRoaXMucmVzb3VyY2VzW3Jlc291cmNlTmFtZSBhcyBrZXlvZiBUXSA9IGNvbnN0cnVjdEZhY3RvcnkuZ2V0SW5zdGFuY2UoXG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3RydWN0Q29udGFpbmVyLFxuICAgICAgICAgICAgb3V0cHV0U3RvcmFnZVN0cmF0ZWd5LFxuICAgICAgICAgICAgaW1wb3J0UGF0aFZlcmlmaWVyLFxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICApIGFzIGFueTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBDREsgc3RhY2sgd2l0aGluIHRoZSBBbXBsaWZ5IHByb2plY3QgdGhhdCBjYW4gYmUgdXNlZCBmb3IgY3JlYXRpbmcgY3VzdG9tIHJlc291cmNlcy5cbiAgICogSWYgYSBzdGFjayBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgd2l0aCBcIm5hbWVcIiB0aGVuIGFuIGVycm9yIGlzIHRocm93bi5cbiAgICovXG4gIGNyZWF0ZVN0YWNrID0gKG5hbWU6IHN0cmluZyk6IFN0YWNrID0+IHtcbiAgICByZXR1cm4gdGhpcy5zdGFja1Jlc29sdmVyLmNyZWF0ZUN1c3RvbVN0YWNrKG5hbWUpO1xuICB9O1xuXG4gIGFkZE91dHB1dCA9IChjbGllbnRDb25maWdQYXJ0OiBQYXJ0aWFsPENsaWVudENvbmZpZz4pID0+XG4gICAgdGhpcy5jdXN0b21PdXRwdXRzQWNjdW11bGF0b3IuYWRkT3V0cHV0KGNsaWVudENvbmZpZ1BhcnQpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgQW1wbGlmeSBiYWNrZW5kIGluc3RhbmNlIGFuZCByZXR1cm5zIGl0XG4gKiBAcGFyYW0gY29uc3RydWN0RmFjdG9yaWVzIC0gbGlzdCBvZiBiYWNrZW5kIGZhY3RvcmllcyBzdWNoIGFzIHRob3NlIGNyZWF0ZWQgYnkgYGRlZmluZUF1dGhgIG9yIGBkZWZpbmVEYXRhYFxuICovXG5leHBvcnQgY29uc3QgZGVmaW5lQmFja2VuZCA9IDxUIGV4dGVuZHMgRGVmaW5lQmFja2VuZFByb3BzPihcbiAgY29uc3RydWN0RmFjdG9yaWVzOiBUXG4pOiBCYWNrZW5kPFQ+ID0+IHtcbiAgY29uc3QgYmFja2VuZCA9IG5ldyBCYWNrZW5kRmFjdG9yeShjb25zdHJ1Y3RGYWN0b3JpZXMpO1xuICByZXR1cm4ge1xuICAgIC4uLmJhY2tlbmQucmVzb3VyY2VzLFxuICAgIGNyZWF0ZVN0YWNrOiBiYWNrZW5kLmNyZWF0ZVN0YWNrLFxuICAgIGFkZE91dHB1dDogYmFja2VuZC5hZGRPdXRwdXQsXG4gIH07XG59O1xuIl19